module root-cpp (*)

import root

type Cpp => Filename = "std::string"
type Cpp => Unit = "mlc::Unit" -- this is an enum with a single element, NOT `void`, which corresponds to bottom
type Cpp => Real = "double"
type Cpp => Int = "int"
type Cpp => Str = "std::string"
type Cpp => Bool = "bool"
type Cpp => (Map a b) = "std::map<$1,$2>" a b
type Cpp => (List a) = "std::vector<$1>" a
type Cpp => (Tuple2 a b) = "std::tuple<$1,$2>" a b
type Cpp => (Tuple3 a b c) = "std::tuple<$1,$2,$3>" a b c
type Cpp => (Tuple4 a b c d) = "std::tuple<$1,$2,$3,$4>" a b c d
type Cpp => (Tuple5 a b c d e) = "std::tuple<$1,$2,$3,$4,$5>" a b c d e
type Cpp => (Tuple6 a b c d e f) = "std::tuple<$1,$2,$3,$4,$5,$6>" a b c d e f
type Cpp => (Tuple7 a b c d e f g) = "std::tuple<$1,$2,$3,$4,$5,$6,$7>" a b c d e f g
type Cpp => (Tuple8 a b c d e f g h) = "std::tuple<$1,$2,$3,$4,$5,$6,$7,$8>" a b c d e f g h

-- used to force C++ usage, mostly in testing
idcpp a :: a -> a 

source Cpp from "core.hpp"
    ( "morloc_id" as idcpp
    , "morloc_fst" as fst
    , "morloc_snd" as snd
    , "morloc_fst3" as fst3
    , "morloc_snd3" as snd3
    , "morloc_thr3" as thr3
    , "morloc_ifelse" as ifelse
    , "morloc_branch" as branch
    , "morloc_not" as not
    , "morloc_and" as and
    , "morloc_or" as or
    , "morloc_zipWith" as zipWith
    )

-- This approach of defining generic instances reduces repetition when every
-- instance will source the same function (the generic "==" function from Cppthon,
-- here). However, it also implies that ALL types are members, even though some
-- things cannot be meaningfully equated. I need a better system.
instance Eq a where
  -- this will work for any type that defines a '==' operator
  source Cpp from "core.hpp" ("morloc_eq" as eq)

instance Ord a where
  -- this will work for any type that defines a '<=' operator
  source Cpp from "core.hpp" ("morloc_le" as le)

instance Integral Int where
  source Cpp from "core.hpp"
    ( "morloc_neg" as neg
    , "morloc_add" as add
    , "morloc_sub" as sub
    , "morloc_mul" as mul
    )
  zero = 0

instance Integral Real where
  source Cpp from "core.hpp"
    ( "morloc_neg" as neg
    , "morloc_add" as add
    , "morloc_sub" as sub
    , "morloc_mul" as mul
    )
  zero = 0.0

instance Numeric Real where
  source Cpp from "core.hpp"
    ( "morloc_inv" as inv
    , "morloc_div" as div
    , "morloc_exp" as exp
    , "morloc_log" as log
    )
  one = 1.0


instance Monoid Str where
  mempty = ""
  source Cpp from "core.hpp" ("morloc_add" as mappend)

instance Monoid (List a) where
  mempty = []
  source Cpp from "core.hpp" ("morloc_add" as mappend)


instance Foldable List where
  -- this will apply to any object in Cppthon that is iterable
  source Cpp from "core.hpp" ("morloc_fold" as fold)

instance Functor List where
  source Cpp from "core.hpp" ("morloc_map" as map)

instance Sequence List where
  empty = []
  source Cpp from "core.hpp"
    ( "morloc_at" as at
    , "morloc_slice" as slice
    )


-------------------------------------------------------------------------------
--                 Pack and Unpack internal functions
-- These functions are used by morloc internally for (de)serialization of types
-- that cannot be automatically (de)serialized into/from JSON. They should not
-- be exported.
-------------------------------------------------------------------------------

type Cpp => (Map key val) = "std::map<$1,$2>" key val

instance Packable ([key],[val]) (Map key val) where
  source Cpp from "data.hpp"
   ( "morloc_packMap" as pack
   , "morloc_unpackMap" as unpack
   )


instance Packable (Int) Unit where
  source Cpp from "data.hpp"
   ( "morloc_packUnit" as pack
   , "morloc_unpackUnit" as unpack
   )
